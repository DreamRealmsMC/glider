sender-system:
  find-target-group: #Featura definuje predem
    sender
    fallback
    last-location

  find-players-for-server: #@event
    sender
    party

  send-method: #abstract class
    hard force
    light force
    queue

  get-available-servers: #@event
    primitive-checker: x # je dostatek slotů a je server online
    maintenance: x

    fail:


  find-best-server-list: #@event  # point system
    friends

  find-server-to-join: Abstract class
    load-balancer (pokud nebude, tak vezme z listu best-server-list)


? only executes when not set or step fails
0 executes if not skipped

0   @Event find players             (Players -rw)
?   @Event find target group        (Players -r, Cluster -r)
0   @Event restricted servers       (Players -rw, Group -r)
0?  @Event available servers        (UnrestrictedServers -r, Players number -r)
0?  @Event find best server list    (AvailableServers -r, Players -r)
    @Event Pre transfer             (SenderResponse -r)

Neni doreseno:
fallback potrebuje reagovat na PreTransfer, ale musi vedet, ze jde o jeho send objekt -> nejakej system na trackovani sendu



/*
PingSubcommand pingCommand = new PingSubcommand();
gliderCommand.registerAsDual(pingCommand, "ping", "latency");
gliderCommand.registerSubcommandProvider(new PingSubcommand());
*/



public class UniqueIDGenerator {
    private final Map<UUID, WeakReference<UUID>> generatedIds = new WeakHashMap<>();

    public synchronized UUID generateUniqueID() {
        UUID newId;
        do {
            newId = UUID.randomUUID();
        } while (generatedIds.containsKey(newId));
        generatedIds.put(newId, new WeakReference<>(newId));
        return newId;
    }

    public void exampleMethod() {
        UUID uuid = generateUniqueID();
        try {
            // Do something with the UUID
            System.out.println("Generated UUID: " + uuid);
        } finally {
            // Ensure the UUID goes out of scope
            uuid = null;
        }
        // At this point, the UUID is no longer referenced and can be reclaimed by the garbage collector
    }
}


database:
  ip: 127.0.0.1
  port: 3306
  username: "username"
  password: "yourpassword"
  databaseName: "database"
  maxPoolSize: 1500

package eu.lenithia.glider.sender.listeners;

import com.google.inject.Inject;
import com.velocitypowered.api.event.Subscribe;
import com.velocitypowered.api.proxy.Player;
import eu.lenithia.glider.GliderVelocity;
import eu.lenithia.glider.clusters.system.GServer;
import eu.lenithia.glider.sender.events.SenderResponseEvent;
import eu.lenithia.glider.sender.objects.SenderResponse;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.format.NamedTextColor;

public class CustomSenderResponseListener {

    private final GliderVelocity glider;

    @Inject
    public CustomSenderResponseListener(GliderVelocity glider) {
        this.glider = glider;
    }

    @Subscribe
    public void onSenderResponse(SenderResponseEvent event) {
        // Only handle SUCCESS and EPIC_FAIL responses
        if (event.getSender().getSenderResponse() == SenderResponse.SUCCESS) {
            handleSuccess(event);
            event.setHandled(true);
        } else if (event.getSender().getSenderResponse() == SenderResponse.EPIC_FAIL) {
            handleEpicFail(event);
            event.setHandled(true);
        }
        // Other responses will use default handling
    }

    private void handleSuccess(SenderResponseEvent event) {
        GServer bestServer = event.getSender().getBestServer();
        if (bestServer != null) {
            for (Player player : event.getSender().getPlayers()) {
                player.sendMessage(Component.text("✓ Connected to ", NamedTextColor.GREEN)
                        .append(Component.text(bestServer.getRegisteredServer().getServerInfo().getName(), NamedTextColor.GOLD)));

                player.createConnectionRequest(bestServer.getRegisteredServer()).connect();

                // Log the transfer
                glider.getLogger().info("Player " + player.getUsername() + " transferred to " +
                        bestServer.getRegisteredServer().getServerInfo().getName());
            }
        }
    }

    private void handleEpicFail(SenderResponseEvent event) {
        for (Player player : event.getSender().getPlayers()) {
            player.sendMessage(Component.text("❌ Transfer failed!", NamedTextColor.RED));
            glider.getLogger().severe("Epic fail occurred when transferring player: " + player.getUsername());
        }
    }
}